# es6相关的面试题

## let、const、var的区别

1. 块级作用域：let和const具有块级作用域，var不存在块级作用域
2. 变量提升： var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。
3. 给全局添加属性： 浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会
4. 重复声明： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。
5. 暂时性死区： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为暂时性死区。使用var声明的变量不存在暂时性死区。
6. 初始值设置： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。
7. 指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。

## 块级作用域解决了ES5中的什么问题？

+ 内层变量可能覆盖外层变量
+ 用来计数的循环变量泄露为全局变量

## const对象的属性可以修改吗？

const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。

但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。

## 如果new一个箭头函数的会怎么样？

箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。

## 箭头函数与普通函数的区别？

1. 箭头函数比普通函数更加简洁：无参数直接书写一个{}, 有一个参数可以省略参数的括号，多个参数逗号分割，函数体的返回值只有一句，可以省略大括号
2. 箭头函数没有自己的this：在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变
3. 箭头函数继承来的this指向永远不会改变
4. call()、apply()、bind()等方法不能改变箭头函数中this的指向
5. 箭头函数不能作为构造函数使用：即不可以使用new
6. 箭头函数没有自己的arguments：箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值
7. 箭头函数没有prototype
8. 箭头函数不能用作Generator函数，不能使用yeild关键字

## 箭头函数的this指向哪⾥？

箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。

##  扩展运算符的作用及使用场景

1. 对象扩展运算符用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中
2. 数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组，可以用于将数组转换为参数序列，复制数组，合并数组，将字符串转为真正的数组
   
##  对对象与数组的解构的理解

解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。 

1. 数组的解构： 在解构数组时，以元素的位置为匹配条件来提取想要的数据的
2. 对象的解构：在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的

## 如何提取高度嵌套的对象里的指定属性？

使用解构赋值

```js
const { school: { name }} = obj
console.log('name', name)
```

## 对 rest 参数的理解?

扩展运算符被用在函数形参上时，它还可以把一个分离的参数序列整合成一个数组, ...rest运算符它可以把函数的多个入参收敛进一个数组里。这一点经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。

## 模板字符串的优势

1. 易读，代码整体的质量都变高
2. 在模板字符串中，空格、缩进、换行都会被保留
3. 模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算

## ES6中还新增了一系列的字符串方法

1. 存在性判定：ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在
   + includes：判断字符串与子串的包含关系
   + startsWith：判断字符串是否以某个/某串字符开头
   + endsWith：判断字符串是否以某个/某串字符结尾
2. 自动重复：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）

##  ES6模块与CommonJS模块有什么异同？

ES6 Module和CommonJS模块的区别：

+ CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；
+ import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。

ES6 Module和CommonJS模块的共同点：

+ CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。
  
## 什么是 Iterable 对象，与 Array 有什么区别

实现了 [Symbol.iterator] 属性的对象即是 Iterable 对象，然后可以使用操作符 for...of 进行迭代

## es6新增了那一些新特性

1. 新增关键词：let / const / async / await / yield
2. 新增关键特性
   1. 模版字符串
   2. 解构赋值 / 展开操作符
   3. promise / ESModule
   4. for...of
   5. async/await
   6. 迭代器接口 iterator
   7. 可选链
3. 新增方法、对象等内容
   1. Proxy / Reflect  代理 / 反射
   2. Set / Map 

## 2. async/await, generator, promise这三者的关联和区别是什么?

## 3. Set和Map

## 4. 装饰器

## 5. generator 是如何做到中断和恢复的

## 6. Symbol

#