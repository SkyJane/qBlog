# javascript基础

## 强类型语言和弱类型语言的区别

+ 强类型语言：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。
+ 弱类型语言：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串'12'和整数3进行连接得到字符串'123'，在相加的时候会进行强制类型转换。

两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。

##  解释性语言和编译型语言的区别

前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。

## JavaScript为什么要进行变量提升，它导致了什么问题？

+ 解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间
+ 声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行

变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。

1. for循环定义的index，由于遍历时定义的index会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来为for循环的长度
2. 函数内外层定义的相同的变量会覆盖
   
## use strict是什么意思 ? 使用它区别是什么？

use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：

1. 消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;
2. 消除代码运行的不安全之处，保证代码运行的安全；
3. 提高编译器效率，增加运行速度；
4. 为未来新版本的 Javascript 做好铺垫。

区别：

1. 禁止使用 with 语句。
2. 禁止 this 关键字指向全局对象。
3. 对象不能有重名的属性。

## new操作符的实现原理

（1）首先创建了一个新的空对象
（2）设置原型，将对象的原型设置为函数的 prototype 对象。
（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）
（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象

```js
function create (fn, ...args) {
    if(typeof fn !== 'function'){
      throw 'newOperator function the first param must be a function';
    }
    // create.target = fn; --- unkown
    let obj = {}
    Object.setPrototypeOf(obj, fn.prototype)
    // 使用指定的参数调用构造函数`Fun`，并将 this 绑定到新创建的对象
    let result = fn.apply(obj, args)
    return result instanceof Object ? result : obj
}
```
## 关于 new，判断以下代码输出

```js
function F () {
 this.a = 3;
 return {
   a: 4;
 }
}

const f = new F();
console.log(f.a);
```

输出 4 new 操作符，默认返回 this 对象。如果手动指定返回对象，则 new 出来的实例指向的是 return 的对象，而不是 this

## Map和Object的区别

|  | Map | Object |
| - | - | - |
| 意外的键 | Map默认情况不包含任何键，只包含显式插入的键。| Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。|
| 键的类型 | Map的键可以是任意值，包括函数、对象或任意基本类型。| Object 的键必须是 String 或是Symbol。|
| 键的顺序 | Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。| Object 的键是无序的|
| Size | Map 的键值对个数可以轻易地通过size 属性获取 | Object 的键值对个数只能手动|
| 计算迭代 | Map 是 iterable 的，所以可以直接被迭代。| 迭代Object需要以某种方式获取它的键然后才能迭代。|
| 性能 | 在频繁增删键值对的场景下表现更好。| 在频繁添加和删除键值对的场景下未作出优化。|

##  map和weakMap的区别

1. Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
2. WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。

##  JavaScript有哪些内置对象?

js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。

## 对JSON的理解

JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。
在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为
JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。
因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。

在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，

+ JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。
+ JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。

## JavaScript脚本延迟加载的方式有哪些？

一般有以下几种方式：

1. defer 属性： 给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。
2. async 属性： 给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。
3. 动态创建 DOM 方式： 动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。
4. 使用 setTimeout 延迟方法： 设置一个定时器来延迟加载js脚本文件
5. 让 JS 最后加载： 将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。

## JavaScript 类数组对象的定义？

一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。

## 常见的类数组转换为数组的方法?

1. Array.prototype.slice.call(arrayLike);
2. Array.prototype.splice.call(arrayLike, 0);
3. Array.prototype.concat.apply([], arrayLike);
4. Array.from(arrayLike);

## 数组具有哪一些原生方法

1. 数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。
2. 数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。
3. 数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。
4. 数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。
5. 数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。
6. 数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法
7. 数组归并方法 reduce() 和 reduceRight() 方法

## 数组的遍历方法有哪些

| 方法 | 是否改变原数组 | 特点 | 
| - | - | - | 
| forEach() | 否 | 数组方法，不改变原数组，没有返回值 | 
| map() | 否 | 数组方法，不改变原数组，有返回值，可链式调用 | 
| filter() | 否 | 数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用 | 
| for...of | 否 | for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 | 
| every() 和 some() | 否 | 数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false. |
| find() 和 findIndex() | 否 | 数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值 | 
| reduce() 和 reduceRight() | 否 | 数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作 | 

##  forEach和map方法有什么区别

这方法都是用来遍历数组的，两者区别如下：

+ forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；
+ map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；
  
## 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?

arguments是一个对象，它的属性是从 0 开始依次递增的数字，还有callee和length等属性，与数组相似；但是它却没有数组常见的方法属性，如forEach, reduce等，所以叫它们类数组。

遍历类数组，有三个方法：

1. Array.prototype.forEach.call(arguments, a => console.log(a))

2. 使用Array.from方法将类数组转化成数组
   
3. 使用展开运算符将类数组转化成数组

## 如何判断一个对象是否属于某个类？

1. 第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。
2. 第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。
3. 第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。

##  for...in和for...of的区别

for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值

+ for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；
+ for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；
+ 对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；
  
for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。

##  如何使用for...of遍历对象

for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。

如果需要遍历的对象是类数组对象，用Array.from转成数组即可。

如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。

```js
var obj = {
    a:1,
    b:2,
    c:3
};
obj[Symbol.iterator] = function *() {
    var keys = Object.keys(obj);
    for(var k of keys){
        yield [k,obj[k]]
    }
};

for(var [k,v] of obj){
    console.log(k,v);
}
```

## 什么是尾调用，使用尾调用有什么好处？

尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。

## 什么是 DOM 和 BOM？

+ DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。
+ BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。

## 常见的DOM操作有哪些

+ DOM 节点的获取
  1. getElementById
  2. getElementsByTagName
  3. getElementsByClassName
  4. querySelectorAll
+ DOM 节点的创建：createElement、appendChild
+ DOM 节点的删除：removeChild
+ 修改 DOM 元素：insertBefore、appendChild
  
## escape、encodeURI、encodeURIComponent 的区别

+ encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。
+ encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。
+ escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。

## ajax、axios、fetch的区别

1. AJAX: 它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下
  + 本身是针对MVC编程，不符合前端MVVM的浪潮
  + 基于原生XHR开发，XHR本身的架构不清晰
  + 不符合关注分离（Separation of Concerns）的原则
  + 配置和调用方式非常混乱，而且基于事件的异步模型不友好。

2. Fetch: 在ES6出现的，使用了ES6中的promise对象，fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象。
   
   fetch的优点：

   + 语法简洁，更加语义化
   + 基于标准 Promise 实现，支持 async/await
   + 更加底层，提供的API丰富（request, response）
   + 脱离了XHR，是ES规范里新的实现方式

   fetch的缺点：

   + fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。
   + fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: 'include'})
   + fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费
   + fetch没有办法原生监测请求的进度，而XHR可以
3. Axios Axios 是一种基于Promise封装的HTTP客户端，其特点如下：
   + 浏览器端发起XMLHttpRequests请求
   + node端发起http请求
   + 支持Promise API
   + 监听请求和返回
   + 对请求和返回进行转化
   + 取消请求
   + 自动转换json数据
   + 客户端支持抵御XSRF攻击

# 原型与原型链

## 对原型、原型链的理解

在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 proto 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。

当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。

**特点：** JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。

## 如何获得对象非原型链上的属性？

使用后`hasOwnProperty()`方法来判断属性是否属于原型链的属性

## 原型链的终点是什么？如何打印出原型链的终点？

原型链的终点是null

Object.prototype.__proto__