# 组件渲染原理  - todo整理

## 组件的挂载流程

1. 组件需要提供一个render函数，渲染函数需要返回虚拟DOM

```js
const VueComponent = {
    data(){
        return {age:13} 
    },
    render(){ // render函数返回要创建的component组件
        return h('p',[h(Text,"I'm Jiang sir"),h('span',this.age+'')])
    }
}
createRenderer(renderOptions).render(h(VueComponent),document.getElementById('app'))
```

2. 在`h`方法里面添加组件类型
   
h方法中传入一个对象说明要渲染的是一个组件。

```js
export const createVNode = (type,props,children = null)=>{
    const shapeFlag = isString(type)  
        ? ShapeFlags.ELEMENT: isObject(type)
        ? ShapeFlags.STATEFUL_COMPONENT:0;
    // ... 稍后可以根据类型来进行组件的挂载
}
```

3. 在patch方法内部增加对组件渲染的逻辑

```js
const patch = (n1,n2,container,anchor?) => {  
switch(type){
        // ...
        default:
            if(shapeFlag & ShapeFlags.ELEMENT){
                processElement(n1,n2,container,anchor)
            }else if(shapeFlag & ShapeFlags.COMPONENT){
                processComponent(n1,n2,container,anchor)
            }
    }
}
```

4. 在processComponent内部处理组件的渲染，包括初次渲染以及更新操作

```js
const processComponent = (n1,n2,container,anchor)=>{
    if(n1 == null){
        mountComponent(n2,container,anchor);
    }else{
        // 组件更新逻辑
    }
}
```

5. 初始化组件 mountComponent

   + 1. 在初始化过程中，我们要关心的是data响应式数据和组件怎么样相关联起来
   + 2. 组件挂载前需要产生一个组件的实例（对象）组件的状态、组件的属性、组件对应的生命周期...
   + 3. 组件的插槽，处理组件的属性...给组建的实例赋值
   + 4. 给组件成生一个effect，这样当组件数据发生改变的时候重新渲染

> 面试题： 组件的优点是什么？
> 
> 1. 复用
> 2. 逻辑拆分
> 3. 方便维护
> 4. vue组件级别更新、合理就好


```js
const mountComponent = (n2,container,anchor)=>{ 
    // 1. 在初始化过程中，我们要关心的是data响应式数据和组件怎么样相关联起来
    // 我们需要将常见的实例保存在vnode上，因为一会更新的时候要用，保存起来方便复用和更新
    const instance = vnode.components = createComponentInstance(vnode)

    // 2. 给组件的实例赋值
    // 这里主要处理属性和插槽
    setupComponent(instance)

    // 3. 给组件成生一个effect，这样当组件数据发生改变的时候重新渲染
    setupRenderer(instance, container, anchor)
}

// components.ts 组件处理逻辑抽离

export function createComponentInstance（vnode） {
    let instance = {
        data: null, // 本身的数据
        vnod, // 标识实例对应的虚拟节点
        subTRee: null, // 组件对应的渲染的虚拟节点
        isMounted: false, //组件是否挂载
        update: null, // 组件暴露更新逻辑给用户，方便用户可以进行强制更新， effect.run
        render:null, // 用户的render函数，对外暴露render函数，可以直接调用处理
    }
    return instance
}

export function setupComponent(instance) {
    // type -> 用户传入的属性
  let { type, props, children } = instance.vnode
  
  let { data, render } = type

  if(data) {
      // 1. data必须是一个对象
     if(!isFunction(data)) {
        console.warn()
     }
     // 2. 给实例赋予好data属性
     instance.data =  reactive(data.call({})) // data变成响应式数据

     // 3. 给实例赋值render函数
    instance.render = render
  }
}

export function  setupRenderer(instance, container, anchor) {
    const componentUpdate = () => {
        const { render } = instance
        if(!instance.isMounted) {
            // 1. 初次渲染
            // 1.1 组件最终要渲染的虚拟节点就是subTree
            // 此处调用render函数会进行依赖收集，稍后数据变化了，会重新调用update方法
            const subTree = render.call(data) // 1.2 改变render函数内部数据的this指向为响应式data的数据
            
            // 1.3 组件初次渲染调用patch方法
            patch(null, subTree, container, anchor)
            // 1.4 给instance实例上面挂载组件的虚拟节点
            instance.subTree = subTree
            // 将组件是否挂载的标识置为true
            instance.isMounted = true
        } else {
            // 更新逻辑
            // 1. 拿到初次渲染的组件的虚拟dom
            const subTree = render.call(data)
             // 2. patch方法进行更新操作
            patch(instance.subTree,subTree, container, anchor)
            // 3. 更改组件的虚拟DOM，指向最新的
            instance.subTree = subTree
        }
    }
    // 1. 创建一个响应式实例
    const effect = new ReactiveEffect(componentUpdate)
    // 2. 调用实例上面的run方法，用户想要强制的更新，找到实例调用update方法,所以将effect.run绑定在intance的update上面
    instance.update = effect.run.bind(effect)

    update() // 3. 更新函数
}
```