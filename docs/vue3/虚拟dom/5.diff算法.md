# diff算法

用户在操作dom节点的时候吗，很少有将儿子变成父亲的情况，因为如果要做完整的两棵树的对比性能会比较差

在比较的过程中，存在两种情况

1. 最上层节点完全不一样
2. 最上层节点一致，但是儿子或者属性有区别

## 最上层节点完全不一样

最上层节点完全不一样，即使内部儿子以及属性完全一致，也不会进入内部进行比较，而是选择直接替换旧节点的方式，加快对比的速度

> 在patch方法内部如何判断 新节点n2 与旧节点n1 是否是相同节点？
> 
> 判断标签名type 和对应的key

如果新老节点不一样，需要卸载n1并且重新挂载n2

```js
function unmount(vnode) {
  hostRemove(vnode.el)
}
function patch(n1,n2, container) {
    if(n1 && !isSameVNode(n1, n2)) {
        unmount(n1)
        n1 = null
    }
}

function render(vnode, container) {
    if(vnode = null) { // 卸载节点
        if(container._vnode) {
            unmount(container._vnode)
        }
    } else { // 更新节点
        patch(container._vnode||null,vnode,container)
    }
}
```
 
## 最上层节点一致，但是儿子或者属性有区别

```js
function processElement(n1,n2) {
  if(n1 === null) {
    mountElement(n1,n2, container)
  } else {
    patchElement(n1, n2, container)
  }
}

function patchElement(n1, n2) {
   // n1 和 n2 如果能复用，dom节点就不用删除两
   // 1. 节点复用 n2.el = n1.el 的意思在于将n1的虚拟dom节点直接赋值给n2，直接使用
   let el = n2.el = n1.el

   let oldProps = n1.props
   let newProps = n2.props
   // 2. 比较属性
   patchProps(oldProps, newProps, el)
   // 3. 对比儿子
   patchChildren(n1, n2, el)
}

function patchChildren(n1, n2, el) {
  let c1 = n1.children // 老儿子
  let c2 = n2.children // 新儿子

  const preShapeFlag = n1.shapeFlag
  const shapeFlag = n2.shapeFlag

  // 开始比较儿子的情况， 9种情况
  //  1. 新儿子文本类型
//         + 旧儿子数组类型，删除节点，设置文本 🐶
//         + 文本类型/空，替换文本
//       2. 新儿子类型数组🐶
//         + 旧儿子数组类型， diff算法 🐶
//         + 文本类型/空、清空文本，挂载数组🐶
//       3. 新儿子为空 🐶
//         + 旧儿子数组类型，删除所有的儿子 🐶
//         + 旧儿子文本类型、清空文本🐶
//         + 空，无需处理
// }
  // 情况1: 新儿子文本类型，老儿子数组、文本、空类型判断
  if(shapeFlag & ShapeFlags.TEXT_CHILDREN) { // 新儿子 - 文本类型
    if(preShapeFlag & ShapeFlags.ARRAY_CHILDREN) { // 旧儿子数组类型 - 删除节点
      unmountChildren(c1)
    }
    if(c1 !== c2) { // 只要新旧儿子不相等，旧儿子是数组/文本/空 都替换
      hostSetElmentText(el,c2)
    }
 } else {
   // 情况2: 新儿子要么是空，要么是数组
   if(preShapeFlag & ShapeFlags.ARRAY_CHILDREN) { // 2.1 旧儿子数组类型
     // 之前是数组，之后也是数组
     if(shapeFlag & ShapeFlags.ARRAY_CHILDREN) { // 2.1 旧儿子数组类型 & 新儿子数组类型 diff算法
       // diff算法
       // [数组，数组]
       patchKeyedChildren(c1, c2, el)
     } else {
       // [空，数组] - 删除儿子
       unmountChildren(c1) // 2.1 旧儿子数组类型 & 新儿子为空 删除儿子
     }
   } else {
      if(preShapeFlag & ShapeFlags.TEXT_CHILDREN) { //  [数组/空, 文本] 清空
        hostSetElementText(el, '')
      }
      // [数组， 文本类型/空] 挂载
      if(shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        mountChildren(c2, el) // 新儿子数组类型 挂载数组
      }
   } 
 }
}

 function unmountChildren(children) {
   children.forEach(child => unmount(child))
 }

```

```js
// diff算法
function patchKeyedChildren(c1, c2, el) {
  // 比较c1和c2两个数组的差异，再去更新el
  // 核心在于尽可能的复用节点，而且找到变化的位置
  // 基础diff算法： 原则上就是拿新的过去比
  // vue3的diff算法的优化点：先考虑一些顺序相同的情况，追加或者删除

  let i = 0 // 头指针
  let e1 = c1.length - 1
  let e2 = c2.length - 1

  // 如果有任何一方对比完成之后，就不需要在进行对比了

  while(i <= e1 && i <= e2) {
    const n1 = e1[i]
    const n2 = e2[i]
    if(isSameVNode(n1,n2)) { // 如果节点相同
      patch(n1, n2, el) // 依次对比两个相同节点的属性、文本等其他是否一致、递归比较
    } else {
      break;
    }
    i++
  }

}
```