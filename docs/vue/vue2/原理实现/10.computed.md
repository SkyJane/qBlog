# computed原理

computed 会根据依赖的数据重新执行，这个方法是不会自己执行的，只有内部取了依赖数据的值时才会进行计算，内部也使用了 defineProperty，内部有一个变量dirty，computed还是一个watcher，内部依赖的属性会收集这个watcher

## 手写一个computed

1. 首先用户传进来的参数具有computed，则进行初始化initComputed

```js
function initState (options){
    if (opts.computed) {
      initComputed(vm,opts.computed);
    }
}
``` 
2. 在初始化过程中，我们会拿到用户定义的computed并将这个computed定义在实例上面，使用Object.defineProperty进行属性拦截，当执行取值操作的时候，就会触发我们定义的get方法，此时是没有缓存的，想要具有缓存功能，就需要定义一个存放计算属性的watcher
```js
function initComputed(vm, computed) {
    // 存放计算属性的watcher
    const watchers = vm._computedWatchers = {};
    for (const key in computed) {
        const userDef = computed[key]; // 取出对应的值
        // 获取get方法
        const getter = typeof userDef === 'function' ? userDef : userDef.get; // 如果是函数拿到get，watcher使用
        // 创建计算属性watcher
        watchers[key] = new Watcher(vm, userDef, () => {}, { lazy: true });
        defineComputed(vm, key, userDef) // 定义这个computed
    }
}
```
每个计算属性也都是一个watcher,计算属性需要表示lazy:true,这样在初始化watcher时不会立即调用计算属性方法


```js
class Watcher {
    constructor(vm, exprOrFn, callback, options) {
        this.vm = vm;
        this.dirty = this.lazy
        // ...
        this.value = this.lazy ? undefined : this.get(); // 调用get方法 会让渲染watcher执行
    }
} 
```

默认计算属性需要保存一个dirty属性，用来实现缓存功能

```js
const sharedPropertyDefinition = {
    enumerable: true,
    configurable: true,
    get: () => {},
    set: () => {}
} // 共享函数属性
function defineComputed(target, key, userDef) {
    if (typeof userDef === 'function') { // 如果是一个函数，就取出用户自定义的get方法进行赋值
        sharedPropertyDefinition.get = createComputedGetter(key)
    } else {
        sharedPropertyDefinition.get = createComputedGetter(userDef.get); // 需要加缓存
        sharedPropertyDefinition.set = userDef.set;
    }
    // 使用defineProperty定义
    Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

```js
function createComputedGetter(key) { // 创建缓存getter
    return function computedGetter() {
        const watcher = this._computedWatchers[key];
        if (watcher) {
            if (watcher.dirty) { // 如果dirty为true
                watcher.evaluate();// 计算出新值，并将dirty 更新为false
            }
            // 如果依赖的值不发生变化，则返回上次计算的结果
            return watcher.value
        }
    }
}
```

watcher.evaluate

```js
evaluate() {
    this.value = this.get()
    this.dirty = false
}

update() {
    if (this.lazy) {
        this.dirty = true;
    } else {
        queueWatcher(this);
    }
}
```

当依赖的属性变化时，会通知watcher调用update方法，此时我们将dirty置换为true。这样再取值时会重新进行计算。

```js
if (watcher) {
    if (watcher.dirty) {
        watcher.evaluate();
    }
    if (Dep.target) { // 计算属性在模板中使用 则存在Dep.target
        watcher.depend()
    }
	return watcher.value
}

depend() {
	let i = this.deps.length
	while (i--) {
		this.deps[i].depend()
	}
}
```

如果计算属性在模板中使用，就让计算属性中依赖的数据也记录渲染watcher,这样依赖的属性发生变化也可以让视图进行刷新