# 模版编译原理

渲染操作：默认会先去找render方法，如果没有传入render方法就会查找template属性，如果都没有就找当前的el指定的元素的内容来进行渲染

template是dom元素，render方法是一个函数，本质上就不是等价的，所以vue提供统一的处理逻辑，使用ast解析template使其转换成redner函数

1. 在`初始化状态`完毕之后，判断是否存在`el`属性，如果有就需要渲染模版，通过`$mount`函数进行挂载操作

```js
Vue.prototype._init = function (options) {
    const vm = this;
    vm.$options = options;
    // 初始化状态
    initState(vm);
    // 页面挂载
    if (vm.$options.el) {
    	vm.$mount(vm.$options.el);
    }
}
```

2. 在`$mount`方法内部进行渲染逻辑判断，首先判断是否有`render`函数，如果有就渲染，如果没有判断是否具有`template`模版，如果没有判断是否具有`el`，如果有`el`直接渲染`el.outerHTML`，如果有`template`模版，则通过`compileToFunctions`方法将`template`编译成`render`函数，渲染的时候都是用的统一的`render`函数

```js
Vue.prototype.$mount = function (el) {
    const vm = this;
    const options = vm.$options;
    el = document.querySelector(el);

    // 如果没有render方法
    if (!options.render) {
        let template = options.template;
        // 如果没有模板但是有el
        if (!template && el) {
        	template = el.outerHTML;
        }
        const render= compileToFunctions(template);
        options.render = render; // 渲染时用的都是这个render
    }
}
```

## 将模版编译成render函数 - compileToFunction

使用ast语法（描述语言本身或者描述js语法）即js语法描述html模版，然后通过这个数重新生成代码，转换成render

> 面试题：虚拟dom和ast的差别
> 
> 答案： 虚拟dom是对对象来描述节点的而ast树是描述语言本身，虚拟dom的结构是随机的，ast树的结构是固定的，虚拟dom强调的是结构，ast树强调的是语法

> 面试题： 怎么将一串div转换成ast

```js
export function compileToFunctions(template) {
    parseHTML(template);
    let code = generate(root);
    let render = `with(this){return ${code}}`;
    let renderFn = new Function(render);
    return renderFn
}
```

### 一、首先解析标签和内容 - `parseHTML`
   
1. 提供一系列解析标签名称、标签属性、标签内容文本的正则表达式，来对html进行匹配处理
  
```js
const ncname = `[a-zA-Z_][\\-\\.0-9_a-zA-Z]*`; // 标签名 aa-aa(字母或者下划线开头，中间是特殊字符-，连接数字下划线或者字母)
const qnameCapture = `((?:${ncname}\\:)?${ncname})`; //匹配标签 ?:匹配不捕获，my:xx（也就是一些特殊的标签 <my:xx>）
const startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名即 <div
const endTag = new RegExp(`^<\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 </div>
const attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/; // 匹配属性的 ->  n个空格，然后n个空格之后的不是空格，不是双引号不是单引号不是<>=之外的（即id），然后?:匹配但不捕获，=号前后都是空格 （即 = ），然后?:匹配但不捕获前面可以是双引号但是中间不能是双引号结尾是双引号，可以是单引号但是中间不能是单引号结尾是单引号( 即 "a" / "'a'" / 'a' / '"a"'),还有一种可能就是即不是空格、双引号、单引号、<>的直接是属性的（即 id = a）
const startTagClose = /^\s*(\/?)>/; // 匹配标签结束的 > -> 以n个空格开头 然后/> 结尾的其中/可有可无(\/?)即 <br />
const defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g // 匹配内容 前面是{{  后面是}}，中间内容可以是任何字符
```

2. 提供解析标签和内容的方法 - `parseHTML`, 解析标签的原理在于正则匹配 & html截取

循环条件在于：只有`html`不为空就一直解析，判断第一个元素是不是`<`开头的：

+ 如果是`<`开头的那一定是`html`标签，
    - 1. 以`<`开头的是开始标签,提供 `parseStartTag `方法解析开始标签匹配的结果，如果匹配结果是有值得，那就处理开始标签调用`start`方法将其转换, 对于 `parseStartTag`方法:
        - 1. 首先判断是不是开始标签，如果是开始标签，创建开始标签的匹配结果`match`(内部包含标签名称`tagName` & 属性数组`attrs`)
        - 2. 然后调用提供的html的前进方法`const advance  = (n) =>  html = html.substring(n);`(该方法将字符串进行截取并且更新html), 开始删除匹配到的开始标签，以便于后续对html的遍历
        - 3. 其次需要判断开始标签内部是否包含标签属性，再次匹配结尾标签， 如果直接是结尾标签说明不具备`attrs`，直接返回`match`结果即可，如果不是结尾标签并且符合属性的正则表达式，那就需要对属性做处理，根据属性的正则匹配拿到的属性的结果存入`match`结果当中，此时的`match = { name: 'id', value: 'app'}`
    - 2. 以`<`开头的是结尾标签: 去匹配结束标签，调用`advance`方法获得最新的html，然后调用结束标签的方法`end`，将结束标签传进去
+ 不是`<`开头的那就是`文本内容text`：如果是文本先截取出文本的内容，然后调用`advance`方法，将html串当中的文本删掉，并调用处理文本的方法 `chars`


```js
// 示例 <div id="a"><div id="my">hello {{name}} <span>world</span></div></div>
function parseHTML(html){
    while(html){ // 只要html不为空一直解析
        let textEnd = html.indexOf('<'); // 判断第一个元素是不是<开头的
        if(textEnd == 0){ // 如果是<开头的那一定是html标签
            console.log('start')
            const startTagMatch = parseStartTag(); // 解析开始标签匹配的结果
            if(startTagMatch){ // 如果有这个结果，那就是有开始标签
                start(startTagMatch.tagName,startTagMatch.attrs);
                continue;
            }
            // 结束标签
            const endTagMatch = html.match(endTag);
            if(endTagMatch){ // 如果有结束标签
                advance(endTagMatch[0].length);
                end(endTagMatch[1]); // 调用结束标签的方法，将结束标签传进去
                continue; // 继续循环
            }
        }
        let text;
        if(textEnd >= 0){ // 文本
            text = html.substring(0,textEnd);
        }
        if(text){ // 如果有文本
            advance(text.length); // 将文本删除，html前进
            chars(text); // 调用处理文本的方法
        }
    }
    function advance(n){ // 将字符串进行截取操作，在更新html
        html = html.substring(n);
    }
    function parseStartTag(){
        // 判断是不是开始标签
        const start = html.match(startTagOpen);
        if(start){
            const match = { // 匹配到的标签名
                tagName:start[1],
                attrs:[] // 标签属性
            }
            advance(start[0].length); // 前进方法，删除开始标签
            let attr,end;
            while(!(end = html.match(startTagClose)) && (attr = html.match(attribute))){ // 匹配不是结尾标签，并且具有attrs的匹配规则的信息的

                // match之后拿到的结果就是 [" id="a"", "id", "=", "a", undefined, undefined, index: 0, ...]
                match.attrs.push({name:attr[1],value:attr[3] ||attr[4] || attr[5] }); // 匹配结果当中存入匹配到的信息 { name: 'id', value: 'a'}
                
                advance(attr[0].length); // 删除属性信息，并将截取结果赋值给html
                
                break;
            }
            if(end){ // 如果是闭合标签，就是没有attrs
                advance(end[0].length); // 把闭合标签也删除掉
                return match // 返回匹配结果
            }
        }
    }
}
```

### 二、生成ast语法树: 语法树就是用对象描述js语法
   
通过树的数据结构来进行解决

```js
let root;
let currentParent; // 当前节点的父亲
let stack = [];
const ELEMENT_TYPE = 1;
const TEXT_TYPE = 3;

function createASTElement(tagName,attrs){
    return {
        tag:tagName, // 标签名
        type:ELEMENT_TYPE, // 标签类型
        children:[], // 子节点
        attrs, // 属性
        parent:null // 父节点
    }
}
// 验证标签是否合法，即<div>的开始标签是否具有闭合标签，通过数据的结构的栈结构的特点，将初始标签放入栈中，然后匹配到根栈中最上层的节点一致就弹出栈顶元素，如果不一样就存入栈中，最后完全匹配上的结果就是栈是空的
function start(tagName, attrs) {
    // 创建一个初始元素
    let element = createASTElement(tagName,attrs);

    if(!root){ // 没有根元素
        root = element;
    }
    currentParent = element;
    stack.push(element); // 标签栈存入栈中，将生产的ast放进去
}
function end(tagName) { // 在即位标签处创建父子关系
    let element = stack.pop(); // 拿到结束标签的时候，就出栈（即标签栈的栈顶元素）
    currentParent = stack[stack.length-1]; // 要更新当前的父亲值，出栈了就代表已经找到了闭合标签，那就是出栈之后的栈顶元素为当前的父亲再去匹配闭合标签 & 内容存到对应的位置
    if(currentParent){
        element.parent = currentParent; // 在闭合的时候可以知道这个标签的父亲是谁
        currentParent.children.push(element); // 并将元素存到父亲的儿子里面
    }
}
function chars(text) {
    // 空格是不需要的，所以将空格删除
    text = text.replace(/\s/g,'');
    if(text){ // 如有文本，当前的父亲下的儿子就存入这个文本
        currentParent.children.push({
            type:TEXT_TYPE,
            text
        })
    }
}
return root
```

### 三、生成代码：template转化成render函数的结果
   
```js
function gen(node) {
    if (node.type == 1) {
        return generate(node);
    } else {
        let text = node.text
        if(!defaultTagRE.test(text)){
            return `_v(${JSON.stringify(text)})`
        }
        let lastIndex = defaultTagRE.lastIndex = 0
        let tokens = [];
        let match,index;
        
        while (match = defaultTagRE.exec(text)) {
            index = match.index;
            if(index > lastIndex){
                tokens.push(JSON.stringify(text.slice(lastIndex,index)));
            }
            tokens.push(`_s(${match[1].trim()})`)
            lastIndex = index + match[0].length;
        }
        if(lastIndex < text.length){
            tokens.push(JSON.stringify(text.slice(lastIndex)))
        }
        return `_v(${tokens.join('+')})`;
    }
}
function getChildren(el) { // 生成儿子节点
    const children = el.children;
    if (children) {
        return `${children.map(c=>gen(c)).join(',')}`
    } else {
        return false;
    }
}
function genProps(attrs){ // 生成属性
    let str = '';
    for(let i = 0; i<attrs.length; i++){
        let attr = attrs[i];
        if(attr.name === 'style'){
            let obj = {}
            attr.value.split(';').forEach(item=>{
                let [key,value] = item.split(':');
                obj[key] = value;
            })
            attr.value = obj;
        }
        str += `${attr.name}:${JSON.stringify(attr.value)},`;
    }
    return `{${str.slice(0,-1)}}`;
}
function generate(el) {
    let children = getChildren(el);
    let code = `_c('${el.tag}',${
        el.attrs.length?`${genProps(el.attrs)}`:'undefined'
    }${
        children? `,${children}`:''
    })`;
    return code;
}
let code = generate(root);

```

1. 生成render函数：

```js
export function compileToFunctions(template) {
    parseHTML(template);
    let code = generate(root);
    let render = `with(this){return ${code}}`;
    let renderFn = new Function(render);
    return renderFn
}
```