# vue-router的基本原理与实现

我们在使用vue-router的过程中发现vue-router核心方法就是Vue.use(Router),在就是new Router产生router实例，所以默认vue-router插件会导出一个类，用户会直接new Router

> 为什么在写vue相关的插件的时候，需要外部传入Vue？
> 主要是因为避免插件内部代码强依赖的关系，导致传进来的高版本或者低版本的vue具有兼容性问题

```JS
import Vue from 'vue'
import Router from 'vue-router'
Vue.use(Router);// 使用Vue-Router插件
export default new Router({ // 创建Vue-router实例，将实例注入到main.js中
    routes: [
        {
            path: '/',
            name: 'home',
            component: Home
       },
    ]
})
new Vue({
  router, // 在根实例中注入router实例
  render: h => h(App)
}).$mount('#app')
```

## 编写vue-router

### 1. 默认我们引用Vue-Router使用的是index.js文件,use方法默认会调用当前返回对象的install方法

```JS
// index.js
import install from './install'
export default class VueRouter{}
VueRouter.install = install; // 提供的install方法
```

### 2. 编写install方法

```js
export let _Vue;
export default function install(Vue) { // 插件的入口
    _Vue = Vue; // 暴露出去，这样别的文件都可以使用Vue变量
    // 我们希望在每一个组件内部都可以具有属性router，所以采用Vue.mixin的混入方式即给所有组件的生命周期都增加beforeCreate方法
    Vue.mixin({
        beforeCreate() {
            // 将父亲传入的router实例共享给所有的组件
            if (this.$options.router) { // 如果有router属性说明是根实例
                this._routerRoot = this; // 给当前根组件增加一个属性，将根实例挂载在_routerRoot属性上，即_routerRoot就是它自己
                this._router = this.$options.router; // 将当前router实例挂载在_router上

                this._router.init(this); // 初始化路由,这里的this指向的是根实例
            } else { // 父组件渲染后会渲染子组件
                // 组件渲染是一层一层渲染的
                this._routerRoot = this.$parent && this.$parent._routerRoot;
                // 保证所有子组件都拥有_routerRoot 属性，指向根实例
                // 保证所有组件都可以通过 this._routerRoot._router 拿到用户传递进来的路由实例对象
            }
        }
    })
}
```

这里我们应该在Vue-Router上增加一个init方法，主要目的就是初始化功能，共享一个router，每一个组件可以拿到相同的router实例进行操作

> 什么是路由？
> 
> 匹配到对应路径显示对应的组件

根据用户传进来的配置和当前请求的路径，渲染对应的组件，我们次吃需要一个匹配器：主要用于后续的匹配组件`createMatcher`, matcher需要提供两个方法: match方法用来匹配规则以及addRoutes用来动态添加路由

```js
import createMatcher from './create-matcher'
import install from './install'
export default class VueRouter{
    constructor(options){
        // 根据用户传递的routes创建匹配关系,this.matcher需要提供两个方法 
        // match：match方法用来匹配规则
        // addRoutes：用来动态添加路由
        this.matcher = createMatcher(options.routes || []);

        this.mode = options.mode || 'hash' // 默认没有置顶模式的话就是hash模式
    }
    init(app){} // 初始化
}
VueRouter.install = install;
```

### 3. 编写createMatcher方法

```js
import createRouteMap from './create-route-map'
export default function createMatcher(routes) {
    // 收集所有的路由路径, 收集路径的对应渲染关系
    // pathList = ['/','/about','/about/a','/about/b']
    // pathMap = {'/':'/的记录','/about':'/about记录'...}
    let { pathList, pathMap } = createRouteMap(routes); // 做扁平化操作
    
    // 这个方法就是动态加载路由的方法
    function addRoutes(routes){
        // 将新增的路由追加到pathList和pathMap中
        createRouteMap(routes,pathList,pathMap);
    }   
    function match(){} // 稍后根据路径找到对应的记录
    return {
        addRoutes, // 添加路由
        match // 匹配路径
    }
}
```

这里需要创建映射关系，需要createRouteMap方法

> 面试重点：addRoutes原理
> 将新增的路由追加到pathList和pathMap中

### 4. 编写createRouteMap方法

```js
export default function createRouteMap(routes,oldPathList,oldPathMap){
    // 当第一次加载的时候没有 pathList 和 pathMap
    let pathList = oldPathList || []; 
    let pathMap = oldPathMap || Object.create(null); // 默认没有传递就是直接创建映射关系
    routes.forEach(route=>{
        // 添加到路由记录，用户配置可能是无限层级，稍后要递归调用此方法
        addRouteRecord(route,pathList,pathMap);
    });
    return { // 导出映射关系
        pathList,
        pathMap
    }
}   
// 将当前路由存储到pathList和pathMap中，深度递归
function addRouteRecord(route,pathList,pathMap,parent){
    // 1. 拿到路由记录，如果是子路由记录 需要增加前缀 
    let path = parent?`${parent.path}/${route.path}`:route.path;
    let record = { // 2. 提取需要的信息
        path,
        component:route.component,
        parent
    }
    // 3. 添加路由
    if(!pathMap[path]){ // 不能定义重复的路由，否则只生效第一个
        pathList.push(path);
        pathMap[path] = record;
    }
    if(route.children){ // 4. 递归添加子路由
        route.children.forEach(r=>{ 
            // 这里需要标记父亲是谁，在遍历儿子的时候将父亲的路径传递进去
            addRouteRecord(r,pathList,pathMap,route);
        })
    }
}
```

该方法主要是处理路径和不同路径对应的记录

### 4. 编写浏览器历史相关代码 - 核心history

```js
import HashHistory from './history/hash'
class Router {
    constructor(options){
        this.matcher = createMatcher(options.routes || []);
        // vue路由有三种模式 hash / h5api /abstract ,为了保证调用时方法一致。我们需要提供一个base类，在分别实现子类，不同模式下通过父类调用对应子类的方法
        options.mode = options.mode || 'hash'
        swith(options.mode) {
            case 'hash': this.history = new HashHistory(this)
            ;
            break;
            case 'history': this.history = new BrowserHistory(this);
            break;
        }
    
    }
}
```
这里我们以hash路由为主,创建hash路由实例

```js
import History from './base'
// hash路由
export default class HashHistory extends History{
    constructor(router){
        super(router);
    }
}
// 路由的基类
export default class History {
    constructor(router){
        this.router = router;
    }
}
```

如果是hash路由,打开网站如果没有hash默认应该添加#/

```js
import History from './base';
function ensureSlash(){ 
    if(window.location.hash){ // 有兼容性问题，一般需要通过去拿window.loction.href自己去判断
        return 
    }
    window.location.hash = '/'
}
export default class HashHistory extends History{
    constructor(router){
        super(router);
        ensureSlash(); // 确保有hash,有一个/路径
    }
}
```

稍后我们在继续扩展路由相关代码，我们先把焦点转向初始化逻辑

```js
class VueRouter{
    init(app){
        const history = this.history;
        // 初始化时，应该先拿到当前路径，进行匹配逻辑

        // 让路由系统过度到某个路径
        const setupHashListener = ()=> {
            history.setupListener(); // 监听路径变化 hashChange
        }
        history.transitionTo( // 父类提供方法负责跳转
            history.getCurrentLocation(), // 获得当前路径子类获取对应的路径
            // 跳转成功后注册路径监听，为视图更新做准备
            setupHashListener // 设置监听器
        )
    }
}
```

这里我们要分别实现 transitionTo(基类方法)、 getCurrentLocation 、setupListener

1. getCurrentLocation实现

```js
function getHash(){
    return window.location.hash.slice(1);
}
export default class HashHistory extends History{
    // 也是要拿到hash值
    getCurrentLocation(){
        return getHash();
    }
}
```
2. setupListener实现

```js
// 
export default class HashHistory extends History{
	// ...
    setupListener(){
        window.addEventListener('hashchange', ()=> {
            // 根据当前hash值 过度到对应路径
            // 当hash值发生变化了，再次拿到hash值进行跳转
            this.transitionTo(getHash());
        })
    }
}
```

3. TransitionTo实现

```js
// base.js
export function createRoute(record, location) { // {path:'/',matched:[record,record]}
    let res = [];
    if (record) { // 如果有记录 
        while(record){
            res.unshift(record); // 就将当前记录的父亲放到前面
            record = record.parent
        }
    }
    return {
        ...location,
        matched: res
    }
}
export default class History {
    constructor(router) {
        this.router = router;
        // 根据记录和路径返回对象,稍后会用于router-view的匹配
        this.current = createRoute(null, {
            path: '/'
        })
    }
    // 核心逻辑
    transitionTo(location, onComplete) {
        // 去匹配路径
        let route = this.router.match(location);
        // 相同路径不必过渡
        if(
            location === route.path && 
            route.matched.length === this.current.matched.length){
            return 
        }
        this.updateRoute(route); // 更新路由即可
        onComplete && onComplete();
    }
    updateRoute(route){ // 跟新current属性
        this.current =route;
    }
}
```


